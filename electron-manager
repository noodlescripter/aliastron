#!/bin/bash

# alias-manager
# Manage Electron app aliases via ~/.electron-apps
# ~/.bashrc will be configured to source ~/.electron-apps automatically.

BASHRC="$HOME/.bashrc"
ALIASES_FILE="$HOME/.electron-apps"
INCLUDE_LINE='[ -f "$HOME/.electron-apps" ] && source "$HOME/.electron-apps"'

# ---- Helpers ----

ensure_include() {
    if ! grep -Fq "$INCLUDE_LINE" "$BASHRC" 2>/dev/null; then
        {
            echo ""
            echo "# Load custom Electron app aliases"
            echo "$INCLUDE_LINE"
        } >> "$BASHRC"
    fi
}

confirm() {
    local prompt="$1"
    read -r -p "$prompt [y/N]: " response
    case "$response" in
        [yY]|[yY][eE][sS]) return 0 ;;
        *) echo "Operation cancelled."; return 1 ;;
    esac
}

portable_sed_delete() {
    # $1: pattern, $2: file
    if sed --version >/dev/null 2>&1; then
        sed -i -E "$1" "$2"
    else
        sed -i '' -E "$1" "$2"
    fi
}

purge_alias_line() {
    local name="$1"
    [ -f "$ALIASES_FILE" ] || return 0
    portable_sed_delete "/^[[:space:]]*alias[[:space:]]+$name=/d" "$ALIASES_FILE"
}

reload_aliases_if_sourced() {
    if [ "${BASH_SOURCE[0]}" != "$0" ]; then
        # shellcheck disable=SC1090
        source "$ALIASES_FILE" 2>/dev/null || true
        echo "Reloaded aliases in current shell."
    else
        echo "⚠️  Run: source $ALIASES_FILE  or open a new terminal to apply changes."
    fi
}

# Parse aliases from ~/.electron-apps into two arrays: NAMES[] and CMDS[]
read_aliases_into_arrays() {
    NAMES=()
    CMDS=()
    [ -f "$ALIASES_FILE" ] || return 0

    while IFS= read -r line; do
        # Only consider lines that look like alias definitions
        [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+[A-Za-z0-9_.:-]+=.*$ ]] || continue
        name=$(echo "$line" | awk -F'[ =]' '{print $2}')
        [ -n "$name" ] || continue

        rhs="${line#*alias $name=}"
        # strip surrounding quotes if present
        rhs="${rhs#\"}"; rhs="${rhs%\"}"
        rhs="${rhs%\'}"; rhs="${rhs#\'}"

        NAMES+=("$name")
        CMDS+=("$rhs")
    done < "$ALIASES_FILE"
}

print_alias_list() {
    read_aliases_into_arrays
    if [ ${#NAMES[@]} -eq 0 ]; then
        echo "No aliases found in $ALIASES_FILE."
        return 1
    fi
    printf "Aliases in %s:\n" "$ALIASES_FILE"
    for i in "${!NAMES[@]}"; do
        idx=$((i+1))
        printf " %2d) %-20s -> %s\n" "$idx" "${NAMES[$i]}" "${CMDS[$i]}"
    done
    return 0
}

# ---- Actions ----

create_alias() {
    local name="$1" url="$2"
    if [ -z "$name" ] || [ -z "$url" ]; then
        echo "Error: Need alias name and URL"
        echo "Usage: $0 create <alias_name> <url>"
        exit 1
    fi

    ensure_include
    if confirm "Create alias '$name' for '$url'?"; then
        mkdir -p "$(dirname "$ALIASES_FILE")"
        touch "$ALIASES_FILE"
        purge_alias_line "$name"
        echo "alias $name=\"/usr/lib/electron37/electron $url > /dev/null 2>&1 &\"" >> "$ALIASES_FILE"
        echo "Alias '$name' created in $ALIASES_FILE."
        reload_aliases_if_sourced
    fi
}

remove_alias() {
    local name="$1"
    if [ -z "$name" ]; then
        echo "Error: Missing alias name"
        echo "Usage: $0 remove <alias_name>"
        exit 1
    fi

    ensure_include
    if confirm "Remove alias '$name'?"; then
        purge_alias_line "$name"
        unalias "$name" 2>/dev/null
        echo "Alias '$name' removed from $ALIASES_FILE."
        reload_aliases_if_sourced
    fi
}

list_aliases() {
    ensure_include
    print_alias_list || true
}

uninstall_interactive() {
    ensure_include
    while true; do
        echo
        if ! print_alias_list; then
            # None left
            return 0
        fi
        echo
        read -r -p "Enter number(s) to remove (e.g., 1 or 1,3,5), or 'q' to quit: " choice
        case "$choice" in
            q|Q)
                echo "Done."
                return 0
                ;;
        esac

        # Build list from comma-separated numbers
        IFS=',' read -r -a picks <<< "$choice"
        TO_REMOVE=()
        for pick in "${picks[@]}"; do
            pick_trimmed="$(echo "$pick" | tr -d '[:space:]')"
            [[ "$pick_trimmed" =~ ^[0-9]+$ ]] || { echo "Invalid selection: $pick"; continue; }
            idx=$((pick_trimmed-1))
            read_aliases_into_arrays  # refresh in case previous loop changed things
            if [ $idx -ge 0 ] && [ $idx -lt ${#NAMES[@]} ]; then
                TO_REMOVE+=("${NAMES[$idx]}")
            else
                echo "Out of range: $pick_trimmed"
            fi
        done

        if [ ${#TO_REMOVE[@]} -eq 0 ]; then
            echo "No valid selections. Nothing to do."
            continue
        fi

        # De-duplicate selections
        mapfile -t TO_REMOVE < <(printf "%s\n" "${TO_REMOVE[@]}" | awk '!seen[$0]++')

        echo "Selected to remove: ${TO_REMOVE[*]}"
        if confirm "Proceed to uninstall selected alias(es)?"; then
            for name in "${TO_REMOVE[@]}"; do
                purge_alias_line "$name"
                unalias "$name" 2>/dev/null
                echo "Removed '$name'."
            done
            reload_aliases_if_sourced
        fi
        # Loop again; menu will reflect current state
    done
}

# ---- Main ----

if [ $# -lt 1 ]; then
    cat <<EOF
Usage:
  $0 create <alias_name> <url>   Create an alias
  $0 remove <alias_name>         Remove an alias by name
  $0 list                        List all aliases in $ALIASES_FILE
  $0 uninstall                   Interactive remove (keeps running until you quit)

Notes:
- Aliases are stored in: $ALIASES_FILE
- .bashrc will source that file automatically (added once)
- Run with:  source $0 <args>  to apply immediately in the current shell
EOF
    exit 1
fi

action="$1"; shift
case "$action" in
    create)     create_alias "$@" ;;
    remove)     remove_alias "$@" ;;
    list)       list_aliases ;;
    uninstall)  uninstall_interactive ;;
    *)          echo "Invalid action: $action"; exit 1 ;;
esac

